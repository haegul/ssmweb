import processing.opengl.*;

Camera myCam;
boolean autoCamera = false;
float VIEW_WIDHT;
float VIEW_HEIGHT;

void setup() {
  VIEW_WIDTH = #_WIDTH_#;
  VIEW_HEIGHT = #_HEIGHT_#;
  size(VIEW_WIDTH, VIEW_HEIGHT, P3D);
  myCam = new Camera(50, true);
  myCam.setTarget( VIEW_WIDTH/2, VIEW_HEIGHT/2, 250 );
}



/********************************************* Camera Start *********************************************/
// the camera movement is combined here with mouse action

void mouseDragged()
{
  if (mouseButton == LEFT)
  {
    myCam.mouseOrbit();
  } else if (mouseButton == RIGHT)
  {
    myCam.mousePan();
  } else if (mouseButton == CENTER)
  {
    myCam.mouseZoom();
  }
}

void mouseScrolled(MouseEvent evt) {
  myCam.mouseZoom( mouseScroll * 7 );
}

// Camera change
void keyPressed() {
  if (key == 'C' || key == 'c') {
    if (autoCamera){
      autoCamera = false;
      }
    else{
      autoCamera = true;
     }
  }
}

class Camera
{
  float rotationSpeed = 0.01; // speed of rotation

  float angleX, angleY, angleZ;
  float currAngleX, currAngleY, currAngleZ;

  float distance;
  float currDistance;

  float transX, transY, transZ;
  float currTransX, currTransY, currTransZ;

  boolean smoothOrbit = false;


  // CONSTRUCTORS
  Camera(float distance)
  {
    setDistance(distance);
  }

  Camera(float distance, boolean smoothMovement)
  {
    this(distance);
    smooth();
    orbit(25,50);
  }

  //METHODS
  void mouseOrbit()
  {
    float dx = mouseX -pmouseX;
    float dy = mouseY -pmouseY;
    orbit(dx, dy);
  }

  void mouseZoom()
  {
    float dy = mouseY -pmouseY;
    this.setDistance(this.distance -dy);
  }

  void mouseZoom(float event)
  {
    float dy = event*10;
    this.setDistance(this.distance -dy);
  }

  void mousePan()
  {
    float dx = mouseX -pmouseX;
    float dy = mouseY -pmouseY;
    pan(dx, dy);
  }

  void pan(float dx, float dy)
  {
    this.transX += dx *cos(currAngleZ) ;//+dx*sin(currAngleX);
    this.transY += -dx*sin(currAngleZ)  +dy * cos(currAngleX);
    this.transZ += -dy *sin(currAngleX) ;
  }

  void orbit(float dx, float dy)
  {
    this.rotCamZ(-dx *rotationSpeed);
    this.rotCamX(-dy *rotationSpeed);
  }

  void setTarget(float x, float y, float z)
  {
    transX = -x;
    transY = -y;
    transZ = -z;
  }

  void smooth()
  {
    smoothOrbit = true;
  }

  void noSmooth()
  {
    smoothOrbit = false;
  }


  void setDistance(float distance)
  {
    this.distance = distance;
  }

  void rotCamX(float angle)
  {
    angleX += angle;
  }

  void rotCamY(float angle)
  {
    angleY += angle;
  }

  void rotCamZ(float angle)
  {
    angleZ += angle;
  }

  /**
   * applies the current camera settings
   * call it in your draw method before any paint job
   **/
  void useCam()
  {
    if (smoothOrbit)
    {
      if (abs(currAngleX-angleX) > 0.01)
        currAngleX += (angleX -currAngleX) /10.0 ;
      if (abs(currAngleY-angleY) > 0.01)
        currAngleY += (angleY -currAngleY) /10.0 ;
      if (abs(currAngleZ-angleZ) > 0.01)
        currAngleZ += (angleZ -currAngleZ) /10.0 ;

      if (abs(currTransX-transX) > 0.01)
        currTransX += (transX -currTransX) /10.0 ;
      if (abs(currTransY-transY) > 0.01)
        currTransY += (transY -currTransY) /10.0 ;
      if (abs(currTransZ-transZ) > 0.01)
        currTransZ += (transZ -currTransZ) /10.0 ;

      if (abs(currDistance-distance) > 0.01)
        currDistance += (distance -currDistance) /10.0 ;
    } else
    {
      currAngleX = angleX;
      currAngleY = angleY;
      currAngleZ = angleZ;

      currTransX = transX;
      currTransY = transY;
      currTransZ = transZ;

      currDistance = distance;
    }

    camera(  0, 0, this.currDistance,
    0, 0, 0,
    0, 1, 0
      );

    rotateX(currAngleX);
    rotateY(currAngleY);
    rotateZ(currAngleZ);

    translate(currTransX, currTransY, currTransZ);
  }

  float getAngleX()
  {
    return currAngleX;
  }

  float getAngleY()
  {
    return currAngleY;
  }

  float getAngleZ()
  {
    return currAngleZ;
  }
}
/********************************************* Camera End *********************************************/
void setupAxis() {
  noStroke();
  fill(255,0,0);
  box(10000,0.5,0.5);
  fill(200,0,0);
  pushMatrix();
  translate(25,0,0);
  box(10);
  popMatrix();

  fill(0,255,0);
  box(0.5,10000,0.5);
  pushMatrix();
  translate(0,-25,0);
  box(10);
  popMatrix();

  fill(0,0,255);
  box(0.5,0.5,10000);
  pushMatrix();
  translate(0,0,25);
  box(10);
  popMatrix();
  fill(255);
}

